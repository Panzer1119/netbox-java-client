/*
 * NetBox API
 * API to access NetBox
 *
 * The version of the OpenAPI document: 3.3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package de.codemakers.netbox.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.net.URI;
import java.time.OffsetDateTime;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import de.codemakers.netbox.client.JSON;

/**
 * Webhook
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2022-08-29T15:14:28.278845400+02:00[Europe/Berlin]")
public class Webhook {
  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private Integer id;

  public static final String SERIALIZED_NAME_URL = "url";
  @SerializedName(SERIALIZED_NAME_URL)
  private URI url;

  public static final String SERIALIZED_NAME_DISPLAY = "display";
  @SerializedName(SERIALIZED_NAME_DISPLAY)
  private String display;

  public static final String SERIALIZED_NAME_CONTENT_TYPES = "content_types";
  @SerializedName(SERIALIZED_NAME_CONTENT_TYPES)
  private Set<String> contentTypes = new LinkedHashSet<>();

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_TYPE_CREATE = "type_create";
  @SerializedName(SERIALIZED_NAME_TYPE_CREATE)
  private Boolean typeCreate = false;

  public static final String SERIALIZED_NAME_TYPE_UPDATE = "type_update";
  @SerializedName(SERIALIZED_NAME_TYPE_UPDATE)
  private Boolean typeUpdate = false;

  public static final String SERIALIZED_NAME_TYPE_DELETE = "type_delete";
  @SerializedName(SERIALIZED_NAME_TYPE_DELETE)
  private Boolean typeDelete = false;

  public static final String SERIALIZED_NAME_PAYLOAD_URL = "payload_url";
  @SerializedName(SERIALIZED_NAME_PAYLOAD_URL)
  private String payloadUrl;

  public static final String SERIALIZED_NAME_ENABLED = "enabled";
  @SerializedName(SERIALIZED_NAME_ENABLED)
  private Boolean enabled;

  /**
   * Gets or Sets httpMethod
   */
  @JsonAdapter(HttpMethodEnum.Adapter.class)
  public enum HttpMethodEnum {
    GET("GET"),
    
    POST("POST"),
    
    PUT("PUT"),
    
    PATCH("PATCH"),
    
    DELETE("DELETE"),
    
    UNKNOWN_DEFAULT_OPEN_API("unknown_default_open_api");

    private String value;

    HttpMethodEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static HttpMethodEnum fromValue(String value) {
      for (HttpMethodEnum b : HttpMethodEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<HttpMethodEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final HttpMethodEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public HttpMethodEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return HttpMethodEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_HTTP_METHOD = "http_method";
  @SerializedName(SERIALIZED_NAME_HTTP_METHOD)
  private HttpMethodEnum httpMethod;

  public static final String SERIALIZED_NAME_HTTP_CONTENT_TYPE = "http_content_type";
  @SerializedName(SERIALIZED_NAME_HTTP_CONTENT_TYPE)
  private String httpContentType;

  public static final String SERIALIZED_NAME_ADDITIONAL_HEADERS = "additional_headers";
  @SerializedName(SERIALIZED_NAME_ADDITIONAL_HEADERS)
  private String additionalHeaders;

  public static final String SERIALIZED_NAME_BODY_TEMPLATE = "body_template";
  @SerializedName(SERIALIZED_NAME_BODY_TEMPLATE)
  private String bodyTemplate;

  public static final String SERIALIZED_NAME_SECRET = "secret";
  @SerializedName(SERIALIZED_NAME_SECRET)
  private String secret;

  public static final String SERIALIZED_NAME_CONDITIONS = "conditions";
  @SerializedName(SERIALIZED_NAME_CONDITIONS)
  private String conditions;

  public static final String SERIALIZED_NAME_SSL_VERIFICATION = "ssl_verification";
  @SerializedName(SERIALIZED_NAME_SSL_VERIFICATION)
  private Boolean sslVerification;

  public static final String SERIALIZED_NAME_CA_FILE_PATH = "ca_file_path";
  @SerializedName(SERIALIZED_NAME_CA_FILE_PATH)
  private String caFilePath;

  public static final String SERIALIZED_NAME_CREATED = "created";
  @SerializedName(SERIALIZED_NAME_CREATED)
  private OffsetDateTime created;

  public static final String SERIALIZED_NAME_LAST_UPDATED = "last_updated";
  @SerializedName(SERIALIZED_NAME_LAST_UPDATED)
  private OffsetDateTime lastUpdated;

  public Webhook() { 
  }

  
  public Webhook(
     Integer id, 
     URI url, 
     String display, 
     OffsetDateTime created, 
     OffsetDateTime lastUpdated
  ) {
    this();
    this.id = id;
    this.url = url;
    this.display = display;
    this.created = created;
    this.lastUpdated = lastUpdated;
  }

   /**
   * Get id
   * @return id
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public Integer getId() {
    return id;
  }




   /**
   * Get url
   * @return url
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public URI getUrl() {
    return url;
  }




   /**
   * Get display
   * @return display
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public String getDisplay() {
    return display;
  }




  public Webhook contentTypes(Set<String> contentTypes) {
    
    this.contentTypes = contentTypes;
    return this;
  }

  public Webhook addContentTypesItem(String contentTypesItem) {
    this.contentTypes.add(contentTypesItem);
    return this;
  }

   /**
   * Get contentTypes
   * @return contentTypes
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")

  public Set<String> getContentTypes() {
    return contentTypes;
  }


  public void setContentTypes(Set<String> contentTypes) {
    this.contentTypes = contentTypes;
  }


  public Webhook name(String name) {
    
    this.name = name;
    return this;
  }

   /**
   * Get name
   * @return name
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")

  public String getName() {
    return name;
  }


  public void setName(String name) {
    this.name = name;
  }


  public Webhook typeCreate(Boolean typeCreate) {
    
    this.typeCreate = typeCreate;
    return this;
  }

   /**
   * Call this webhook when a matching object is created.
   * @return typeCreate
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Call this webhook when a matching object is created.")

  public Boolean getTypeCreate() {
    return typeCreate;
  }


  public void setTypeCreate(Boolean typeCreate) {
    this.typeCreate = typeCreate;
  }


  public Webhook typeUpdate(Boolean typeUpdate) {
    
    this.typeUpdate = typeUpdate;
    return this;
  }

   /**
   * Call this webhook when a matching object is updated.
   * @return typeUpdate
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Call this webhook when a matching object is updated.")

  public Boolean getTypeUpdate() {
    return typeUpdate;
  }


  public void setTypeUpdate(Boolean typeUpdate) {
    this.typeUpdate = typeUpdate;
  }


  public Webhook typeDelete(Boolean typeDelete) {
    
    this.typeDelete = typeDelete;
    return this;
  }

   /**
   * Call this webhook when a matching object is deleted.
   * @return typeDelete
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Call this webhook when a matching object is deleted.")

  public Boolean getTypeDelete() {
    return typeDelete;
  }


  public void setTypeDelete(Boolean typeDelete) {
    this.typeDelete = typeDelete;
  }


  public Webhook payloadUrl(String payloadUrl) {
    
    this.payloadUrl = payloadUrl;
    return this;
  }

   /**
   * This URL will be called using the HTTP method defined when the webhook is called. Jinja2 template processing is supported with the same context as the request body.
   * @return payloadUrl
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "This URL will be called using the HTTP method defined when the webhook is called. Jinja2 template processing is supported with the same context as the request body.")

  public String getPayloadUrl() {
    return payloadUrl;
  }


  public void setPayloadUrl(String payloadUrl) {
    this.payloadUrl = payloadUrl;
  }


  public Webhook enabled(Boolean enabled) {
    
    this.enabled = enabled;
    return this;
  }

   /**
   * Get enabled
   * @return enabled
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public Boolean getEnabled() {
    return enabled;
  }


  public void setEnabled(Boolean enabled) {
    this.enabled = enabled;
  }


  public Webhook httpMethod(HttpMethodEnum httpMethod) {
    
    this.httpMethod = httpMethod;
    return this;
  }

   /**
   * Get httpMethod
   * @return httpMethod
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public HttpMethodEnum getHttpMethod() {
    return httpMethod;
  }


  public void setHttpMethod(HttpMethodEnum httpMethod) {
    this.httpMethod = httpMethod;
  }


  public Webhook httpContentType(String httpContentType) {
    
    this.httpContentType = httpContentType;
    return this;
  }

   /**
   * The complete list of official content types is available &lt;a href&#x3D;\&quot;https://www.iana.org/assignments/media-types/media-types.xhtml\&quot;&gt;here&lt;/a&gt;.
   * @return httpContentType
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The complete list of official content types is available <a href=\"https://www.iana.org/assignments/media-types/media-types.xhtml\">here</a>.")

  public String getHttpContentType() {
    return httpContentType;
  }


  public void setHttpContentType(String httpContentType) {
    this.httpContentType = httpContentType;
  }


  public Webhook additionalHeaders(String additionalHeaders) {
    
    this.additionalHeaders = additionalHeaders;
    return this;
  }

   /**
   * User-supplied HTTP headers to be sent with the request in addition to the HTTP content type. Headers should be defined in the format &lt;code&gt;Name: Value&lt;/code&gt;. Jinja2 template processing is supported with the same context as the request body (below).
   * @return additionalHeaders
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "User-supplied HTTP headers to be sent with the request in addition to the HTTP content type. Headers should be defined in the format <code>Name: Value</code>. Jinja2 template processing is supported with the same context as the request body (below).")

  public String getAdditionalHeaders() {
    return additionalHeaders;
  }


  public void setAdditionalHeaders(String additionalHeaders) {
    this.additionalHeaders = additionalHeaders;
  }


  public Webhook bodyTemplate(String bodyTemplate) {
    
    this.bodyTemplate = bodyTemplate;
    return this;
  }

   /**
   * Jinja2 template for a custom request body. If blank, a JSON object representing the change will be included. Available context data includes: &lt;code&gt;event&lt;/code&gt;, &lt;code&gt;model&lt;/code&gt;, &lt;code&gt;timestamp&lt;/code&gt;, &lt;code&gt;username&lt;/code&gt;, &lt;code&gt;request_id&lt;/code&gt;, and &lt;code&gt;data&lt;/code&gt;.
   * @return bodyTemplate
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Jinja2 template for a custom request body. If blank, a JSON object representing the change will be included. Available context data includes: <code>event</code>, <code>model</code>, <code>timestamp</code>, <code>username</code>, <code>request_id</code>, and <code>data</code>.")

  public String getBodyTemplate() {
    return bodyTemplate;
  }


  public void setBodyTemplate(String bodyTemplate) {
    this.bodyTemplate = bodyTemplate;
  }


  public Webhook secret(String secret) {
    
    this.secret = secret;
    return this;
  }

   /**
   * When provided, the request will include a &#39;X-Hook-Signature&#39; header containing a HMAC hex digest of the payload body using the secret as the key. The secret is not transmitted in the request.
   * @return secret
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "When provided, the request will include a 'X-Hook-Signature' header containing a HMAC hex digest of the payload body using the secret as the key. The secret is not transmitted in the request.")

  public String getSecret() {
    return secret;
  }


  public void setSecret(String secret) {
    this.secret = secret;
  }


  public Webhook conditions(String conditions) {
    
    this.conditions = conditions;
    return this;
  }

   /**
   * A set of conditions which determine whether the webhook will be generated.
   * @return conditions
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "A set of conditions which determine whether the webhook will be generated.")

  public String getConditions() {
    return conditions;
  }


  public void setConditions(String conditions) {
    this.conditions = conditions;
  }


  public Webhook sslVerification(Boolean sslVerification) {
    
    this.sslVerification = sslVerification;
    return this;
  }

   /**
   * Enable SSL certificate verification. Disable with caution!
   * @return sslVerification
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Enable SSL certificate verification. Disable with caution!")

  public Boolean getSslVerification() {
    return sslVerification;
  }


  public void setSslVerification(Boolean sslVerification) {
    this.sslVerification = sslVerification;
  }


  public Webhook caFilePath(String caFilePath) {
    
    this.caFilePath = caFilePath;
    return this;
  }

   /**
   * The specific CA certificate file to use for SSL verification. Leave blank to use the system defaults.
   * @return caFilePath
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The specific CA certificate file to use for SSL verification. Leave blank to use the system defaults.")

  public String getCaFilePath() {
    return caFilePath;
  }


  public void setCaFilePath(String caFilePath) {
    this.caFilePath = caFilePath;
  }


   /**
   * Get created
   * @return created
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public OffsetDateTime getCreated() {
    return created;
  }




   /**
   * Get lastUpdated
   * @return lastUpdated
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public OffsetDateTime getLastUpdated() {
    return lastUpdated;
  }





  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Webhook webhook = (Webhook) o;
    return Objects.equals(this.id, webhook.id) &&
        Objects.equals(this.url, webhook.url) &&
        Objects.equals(this.display, webhook.display) &&
        Objects.equals(this.contentTypes, webhook.contentTypes) &&
        Objects.equals(this.name, webhook.name) &&
        Objects.equals(this.typeCreate, webhook.typeCreate) &&
        Objects.equals(this.typeUpdate, webhook.typeUpdate) &&
        Objects.equals(this.typeDelete, webhook.typeDelete) &&
        Objects.equals(this.payloadUrl, webhook.payloadUrl) &&
        Objects.equals(this.enabled, webhook.enabled) &&
        Objects.equals(this.httpMethod, webhook.httpMethod) &&
        Objects.equals(this.httpContentType, webhook.httpContentType) &&
        Objects.equals(this.additionalHeaders, webhook.additionalHeaders) &&
        Objects.equals(this.bodyTemplate, webhook.bodyTemplate) &&
        Objects.equals(this.secret, webhook.secret) &&
        Objects.equals(this.conditions, webhook.conditions) &&
        Objects.equals(this.sslVerification, webhook.sslVerification) &&
        Objects.equals(this.caFilePath, webhook.caFilePath) &&
        Objects.equals(this.created, webhook.created) &&
        Objects.equals(this.lastUpdated, webhook.lastUpdated);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, url, display, contentTypes, name, typeCreate, typeUpdate, typeDelete, payloadUrl, enabled, httpMethod, httpContentType, additionalHeaders, bodyTemplate, secret, conditions, sslVerification, caFilePath, created, lastUpdated);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Webhook {\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    url: ").append(toIndentedString(url)).append("\n");
    sb.append("    display: ").append(toIndentedString(display)).append("\n");
    sb.append("    contentTypes: ").append(toIndentedString(contentTypes)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    typeCreate: ").append(toIndentedString(typeCreate)).append("\n");
    sb.append("    typeUpdate: ").append(toIndentedString(typeUpdate)).append("\n");
    sb.append("    typeDelete: ").append(toIndentedString(typeDelete)).append("\n");
    sb.append("    payloadUrl: ").append(toIndentedString(payloadUrl)).append("\n");
    sb.append("    enabled: ").append(toIndentedString(enabled)).append("\n");
    sb.append("    httpMethod: ").append(toIndentedString(httpMethod)).append("\n");
    sb.append("    httpContentType: ").append(toIndentedString(httpContentType)).append("\n");
    sb.append("    additionalHeaders: ").append(toIndentedString(additionalHeaders)).append("\n");
    sb.append("    bodyTemplate: ").append(toIndentedString(bodyTemplate)).append("\n");
    sb.append("    secret: ").append(toIndentedString(secret)).append("\n");
    sb.append("    conditions: ").append(toIndentedString(conditions)).append("\n");
    sb.append("    sslVerification: ").append(toIndentedString(sslVerification)).append("\n");
    sb.append("    caFilePath: ").append(toIndentedString(caFilePath)).append("\n");
    sb.append("    created: ").append(toIndentedString(created)).append("\n");
    sb.append("    lastUpdated: ").append(toIndentedString(lastUpdated)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("id");
    openapiFields.add("url");
    openapiFields.add("display");
    openapiFields.add("content_types");
    openapiFields.add("name");
    openapiFields.add("type_create");
    openapiFields.add("type_update");
    openapiFields.add("type_delete");
    openapiFields.add("payload_url");
    openapiFields.add("enabled");
    openapiFields.add("http_method");
    openapiFields.add("http_content_type");
    openapiFields.add("additional_headers");
    openapiFields.add("body_template");
    openapiFields.add("secret");
    openapiFields.add("conditions");
    openapiFields.add("ssl_verification");
    openapiFields.add("ca_file_path");
    openapiFields.add("created");
    openapiFields.add("last_updated");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("content_types");
    openapiRequiredFields.add("name");
    openapiRequiredFields.add("payload_url");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to Webhook
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (Webhook.openapiRequiredFields.isEmpty()) {
          return;
        } else { // has required fields
          throw new IllegalArgumentException(String.format("The required field(s) %s in Webhook is not found in the empty JSON string", Webhook.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!Webhook.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Webhook` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : Webhook.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if (jsonObj.get("url") != null && !jsonObj.get("url").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `url` to be a primitive type in the JSON string but got `%s`", jsonObj.get("url").toString()));
      }
      if (jsonObj.get("display") != null && !jsonObj.get("display").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `display` to be a primitive type in the JSON string but got `%s`", jsonObj.get("display").toString()));
      }
      // ensure the json data is an array
      if (jsonObj.get("content_types") != null && !jsonObj.get("content_types").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `content_types` to be an array in the JSON string but got `%s`", jsonObj.get("content_types").toString()));
      }
      if (jsonObj.get("name") != null && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if (jsonObj.get("payload_url") != null && !jsonObj.get("payload_url").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `payload_url` to be a primitive type in the JSON string but got `%s`", jsonObj.get("payload_url").toString()));
      }
      if (jsonObj.get("http_method") != null && !jsonObj.get("http_method").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `http_method` to be a primitive type in the JSON string but got `%s`", jsonObj.get("http_method").toString()));
      }
      if (jsonObj.get("http_content_type") != null && !jsonObj.get("http_content_type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `http_content_type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("http_content_type").toString()));
      }
      if (jsonObj.get("additional_headers") != null && !jsonObj.get("additional_headers").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `additional_headers` to be a primitive type in the JSON string but got `%s`", jsonObj.get("additional_headers").toString()));
      }
      if (jsonObj.get("body_template") != null && !jsonObj.get("body_template").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `body_template` to be a primitive type in the JSON string but got `%s`", jsonObj.get("body_template").toString()));
      }
      if (jsonObj.get("secret") != null && !jsonObj.get("secret").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `secret` to be a primitive type in the JSON string but got `%s`", jsonObj.get("secret").toString()));
      }
      if (jsonObj.get("conditions") != null && !jsonObj.get("conditions").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `conditions` to be a primitive type in the JSON string but got `%s`", jsonObj.get("conditions").toString()));
      }
      if (jsonObj.get("ca_file_path") != null && !jsonObj.get("ca_file_path").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ca_file_path` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ca_file_path").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Webhook.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Webhook' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Webhook> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Webhook.class));

       return (TypeAdapter<T>) new TypeAdapter<Webhook>() {
           @Override
           public void write(JsonWriter out, Webhook value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Webhook read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of Webhook given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of Webhook
  * @throws IOException if the JSON string is invalid with respect to Webhook
  */
  public static Webhook fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Webhook.class);
  }

 /**
  * Convert an instance of Webhook to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

